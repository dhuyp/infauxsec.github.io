---
layout: post
title: "Les langages qui feront de vous une star sur GitHub"
author: "Hans Gruber"
image: "/assets/github-star.png"
tags: ['github', 'langage']
category: code
twitter_text: "les langages qui vous rendront populaire en 2018"
introduction: "Infauxsec News dévoile la collection 2018"
---

Le paysage des langages de programmation les plus populaires est en perpétuelle
évolution, et il n'est pas toujours facile de faire son choix parmi la
multitude de choix qui s'offre à vous. Infauxsec News a listé pour vous les
valeurs sûres de 2018 qui vous permettront de vous épanouir personnellement
comme professionnellement, ainsi que d'acquérir plein de stars sur GitHub.

## JavaScript

```javascript

function iLoveJS () {
   return
   {
      love: 'js'
   }
}

function iLoveJSMore() {
   return {
      love: 'js'
   }
}

typeof iLoveJS() === typeof iLoveJSMore(); //false
```

Un choix conventionnel mais qui reste très efficace en 2018, l'élégance
superficielle et casual de JavaScript se mariera à merveille avec votre Mac.
Les nombreux trous volontaires dans la documentation et la spécification
hasardeuse vous laisseront également tout loisir d'exprimer votre fibre
artistique dans votre code.

## ~~PHP~~ Python 4

```php

if (md5('240610708') == md5('QNKCDZO') {
  echo "I hate Python 4!";
} else {
  echo "Just kidding, of course I love Python 4!";
}
```

Osez tabler sur une combinaison jouant sur l'harmonie, la robustesse et la
stabilité du code en installant ~~PHP~~ Python 4 sur votre Windows ME. Vous écartez ici
la touche de fantaisie que l'on pouvait trouver du côté de JavaScript pour mieux
vous concentrer sur les aspects fonctionnels du code ; l'image que vous
donnerez sera celle d'un loup de mer charismatique fidèle à des outils qui ont
su passer le test du temps.

## Java

```java
package io.github.infauxsec.slash.slash.colon.http.src.i.love.java.crypto.here;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.security.NoSuchAlgorithmException;
import com.google.common.base.Charsets;
import com.google.common.io.BaseEncoding;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import javax.crypto.BadPaddingException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
```

Choisissez Java pour vous attirer les faveurs du monde corporate où ce langage
est très populaire depuis son inception. Vous tablez ici sur un code concis et
clair, avec peu de dépendances et une arborescence de dossiers minimaliste.
Profitez de design patterns comme la factory method qui vous permettra de
bien communiquer l'intérêt de tout encapsuler dans des classes à tous vos
admirateurs. Couplez la légèreté de Java à l'IDE Eclipse (qui est tout aussi
léger) ainsi qu'au tool de build Maven pour vous retrouver avec une stack axée
sur l'efficacité à tous les niveaux.

Certains détracteurs osent comparer Java à la Amsterdam Maximator car *« il n'y
a que les beaufs et les clodos qui l'utilisent »*, accusations infondées que
toute la rédaction dénonce vivement.

## C-Dièse

```csharp
using System;
using System.Security;
using System.Security.Cryptography;
using System.Security.Cryptography.Pkcs;
using System.Security.Cryptography.X509Certificates;
```

Choisissez C-Dièse pour vous positionner totalement a l'opposé de Java, et
bien montrer à quel point vous êtes différent. Vous tablez ici sur un code
concis et clair, avec peu de dépendances et une arborescence de dossiers
minimaliste. Profitez de design patterns comme la factory method qui vous
permettra de bien communiquer l'intérêt de tout encapsuler dans des classes
à tous vos admirateurs. Et surtout, n'oubliez pas de vous la péter devant
ces bouseux de devs Java, avec leur langage moisi qui ne gère même pas
les propriétés.

Soyez cependant attentifs à la faute de goût : Le langage doit se prononcer
*« C-Dièse »* en toutes circonstances. On tolèrera *« C-Hashtag »* pour les
plus jeunes, mais aucune autre forme ne sera admise sous peine de passer
pour un gros inculte.

## Rust

```rust
/*
fn say_hello(name: &str) -> str {
    
    //let hello = "Hello, ";

    //let helloworld = hello + name; // Compile error cannot concatenate two str ? wtf

    let hello = "Hello, ".to_owned(); // what ?? why ?
    let helloworld = hello + world;
    helloworld

}

// fucking type error, try again ???

*/ 

fn say_hello(name: &str) -> String // Why ????

    let hello = "Hello, ".to_owned();
    let helloworld = hello + name;
    helloworld

}
```

Optez pour la simplicité pure d'un système de types élégant (pourquoi
se contenter d'un seul type pour les strings ?). La foison de génériques
incompréhensibles pour les tâches les plus simples forcera l'admiration
de votre patron et assurera la pérennité de votre emploi pour les 10 années
à venir.

À combiner absolument avec un Desktop linux tournant sous une distribution
occulte comme Exherbo ou Sourcemage. Surtout pas Gentoo, qui est beaucoup trop
mainstream.


## Idris

```haskell
-- On définit l'addition (unaire)
plus : Nat -> Nat -> Nat
plus Z     y = y
plus (S k) y = S (plus k y)

-- On prouve que l'addition est associative
associative_proof : {x: Nat} -> 
                    {y: Nat} -> 
                    {z: Nat} ->
                    (x + (y + z)) = ((x + y) + z)

associative_proof {x=0} = Refl  -- cas trivial 0+(y+z) = (y+z) = ((0+y)+z)
associative_proof {x=(S k)} = rewrite (associative_proof {x=k}) in Refl -- cas inductif 

-- Ok, on peut utiliser l'addition en toute confiance maintenant
```

Si les boucles sont un concept trop impur pour vous, que vous ne jurez que par
la correspondance de Curry-Howard et avez une belle barbe, Idris est fait pour
vous. Vous pourrez ainsi arborer une liste conséquente de preuves de concept
inutiles mais intéressantes sur votre GitHub, contribuant ainsi aux efforts de
la communauté scientifique à rendre son code utilisable en production.

## Go

```go
type Container []interface{}

func (c *Container) Put(elem interface{}) {
    *c = append(*c, elem)
}
    
func (c *Container) Get() interface{} {
    elem := (*c)[0]
    *c = (*c)[1:]
    return elem
}

elem, ok := intContainer.Get().(int) // assert that the actual type is int
if !ok {
    fmt.Println("Unable to read an int from intContainer")
}
```

Vous avez fait du C toute votre vie, et l'idée d'apprendre une syntaxe différente
vous hérisse ? Vous n'avez jamais vraiment compris l'utilité des templates C++ ? 
Vous n'avez jamais vraiment réussi non plus a écrire un programme qui ne leak
pas de mémoire ? Vous n'avez jamais entendu parler des moniteurs Java, et de
toute façon vous n'accepteriez qu'un langage compilé nativement, puisque
la performance est essentielle pour vos algorithmes en O(2<sup>2<sup>n</sup></sup>) ? Alors Go
est fait pour vous.

Pour éviter la faute de goût ultime, veillez à adopter un look correct
sous peine d'être la risée de tout le Starbucks : le port du catogan
et de la moustache à la Dali est indispensable.

Et vous, avec quel langage allez-vous briller ?
